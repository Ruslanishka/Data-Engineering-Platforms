-- Задание 1: Рассчитать выручку по категориям

SELECT 
    category,                          -- Выбираем поле "category" для группировки данных
    SUM(sales) AS total_revenue        -- Суммируем значения поля "sales" для каждой категории
FROM 
    orders                             -- Используем таблицу "orders", где хранятся данные о заказах
GROUP BY 
    category                           -- Группируем данные по полю "category"
ORDER BY 
    total_revenue DESC;                -- Сортируем результаты по убыванию выручки

-- Добавление индекса для ускорения группировки и сортировки
CREATE INDEX idx_orders_category ON orders (category);

/*
Логика:
- Запрос агрегирует данные из таблицы `orders`, суммируя значения поля `sales` для каждой категории товаров (`category`).
- Используется функция `SUM()` для расчета общей выручки, а `GROUP BY` — для группировки данных по категориям.

Обоснование выбора типов данных:
- Поле `category` имеет тип `VARCHAR2(255)` для хранения текстовых значений названий категорий.
- Поле `sales` имеет числовой тип (например, `NUMBER`), что позволяет выполнять арифметические операции.

Пояснения по использованию индексов:
- Для ускорения выполнения запроса рекомендуется создать индекс на поле `category`, так как оно используется в операции группировки.

Особенности реализации:
- Если в таблице есть записи с отрицательными значениями `sales` (например, возвраты), они также будут учтены в расчетах. Это корректно, если бизнес-логика допускает такие случаи.
*/


-- Задание 2: Создать таблицу по прибыли подкатегорий

CREATE TABLE subcategory_profit (
    subcategory VARCHAR(255),         -- Поле для хранения названий подкатегорий
    total_profit FLOAT                 -- Поле для хранения суммарной прибыли
);

INSERT INTO subcategory_profit (subcategory, total_profit)
SELECT 
    subcategory,                       -- Выбираем поле "subcategory" для группировки данных
    SUM(profit) AS total_profit         -- Суммируем значения поля "profit" для каждой подкатегории
FROM 
    orders                              -- Используем таблицу "orders", где хранятся данные о заказах
GROUP BY 
    subcategory;                       -- Группируем данные по полю "subcategory"

SELECT * FROM subcategory_profit       -- Проверяем значения в созданной таблице

-- Добавление индексов для ускорения группировки и запросов
CREATE INDEX idx_orders_subcategory ON orders (subcategory);
CREATE INDEX idx_subcategory_profit_subcategory ON subcategory_profit (subcategory);

/*
Описание:
- Создаем новую таблицу `subcategory_profit` с двумя полями: `subcategory` для хранения названий подкатегорий и `total_profit` для хранения суммарной прибыли.
- Затем заполняется таблица данными из таблицы `orders`, где вычисляется общая прибыль для каждой подкатегории.

Обоснование выбора типов данных:
- Поле `subcategory` имеет тип `VARCHAR2(11)`, так как оно содержит текстовые значения названий подкатегорий.
- Поле `total_profit` имеет числовой тип `NUMERIC(21,16)`, так как при создании таблицы для поля `subcategory` использовался этот же тип, из чего следует, что требуются очень точные значения (16 знаков после запятой).

Пояснения по использованию индексов:
Индекс на поле subcategory в таблице orders:
- Для ускорения выполнения запроса, который группирует данные по полю subcategory и вычисляет сумму profit
Индекс на поле subcategory в таблице subcategory_profit:
- Этот индекс ускоряет последующие запросы к таблице subcategory_profit.

Особенности реализации:
- Таблица создается один раз, после чего может быть использована для аналитических запросов без необходимости повторного вычисления данных.
- Если в таблице `orders` есть записи с отрицательными значениями `profit` (например, убытки), они также будут учтены в расчетах.
*/

-- Задание 3: Найти количество клиентов по городам
SELECT 
    g.city,                             -- Выбираем поле "city" из таблицы geo_dim
    COUNT(DISTINCT sf.cust_id) AS customer_count  -- Подсчитываем уникальных клиентов для каждого города
FROM 
    dw.sales_fact sf                    -- Используем таблицу фактов sales_fact
JOIN 
    dw.geo_dim g                        -- Объединяем с таблицей измерений geo_dim
ON 
    sf.geo_id = g.geo_id                -- Условие объединения: совпадение geo_id
GROUP BY 
    g.city                              -- Группируем данные по полю "city"
ORDER BY 
    customer_count DESC;                -- Сортируем результаты по убыванию количества клиентов

-- Добавление индексов для ускорения объединения и группировки
CREATE INDEX idx_sales_fact_geo_id ON dw.sales_fact (geo_id);
CREATE INDEX idx_geo_dim_geo_id ON dw.geo_dim (geo_id);
CREATE INDEX idx_geo_dim_city ON dw.geo_dim (city);

/*
Описание логики работы запроса:
- Запрос использует таблицу фактов `dw.sales_fact` и таблицу измерений `dw.geo_dim`.
- Для каждого города (`city`) из таблицы `dw.geo_dim` подсчитывается количество уникальных клиентов (`COUNT(DISTINCT sf.cust_id)`).
- Объединение происходит по полю `geo_id`, которое связывает таблицы `dw.sales_fact` и `dw.geo_dim`.

Пояснения по использованию индексов:
Индекс на поле geo_id в таблице dw.sales_fact:
- Для ускорения выполнения запроса, который объединяет таблицы dw.sales_fact и dw.geo_dim по полю geo_id.
Индекс на поле geo_id в таблице dw.geo_dim:
- Для ускорения выполнения запроса, который объединяет таблицы dw.sales_fact и dw.geo_dim по полю geo_id.
Индекс на поле city в таблице dw.geo_dim:
- Для ускорения выполнения запроса, который группирует данные по полю city и вычисляет количество уникальных клиентов.

Особенности реализации:
- Использование `COUNT(DISTINCT ...)` используется, чтобы каждый клиент был учтен только один раз, даже если он сделал несколько заказов.
*/
